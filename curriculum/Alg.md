# Algorithms (or "CLRS")

### cd: High Level


* Write proofs using induction, recurrence.
* Formalize Big O in proofs.
* Model and present results of exploring different algorithmic approaches.
* Cover sorting in depth.
* Study Graphs

### cd: vs Roberts

I developed these goals independently then compared against Roberts' defined goals. For Alg, this is mostly from looking at book chapters with HC and seeing what students are working on.

* (+) Basic Automata Computability and Complexity 1, 2, 4
  * Used in complexity proofs seen on Discord.
* (+) Introduction to Modeling and Simulation
  * Used in presentation of results debugged on Discord.
* (+) DISCRETE STRUCTURES/Graphs and Trees
  * Proof techniques seen in Discord.
  * Counting covered in relevant CLRS Chapters. 

## ALGORITHMS

### Basic Analysis [2 hours]

1. Explain what is meant by “best”, “expected”, and “worst” case behavior of an algorithm. [Familiarity]
2. In the context of specific algorithms, identify the characteristics of data and/or other conditions or
assumptions that lead to different behaviors. [Assessment]
3. Determine informally the time and space complexity of simple algorithms. [Usage]
4. State the formal definition of big O. [Familiarity]
5. List and contrast standard complexity classes. [Familiarity]
6. Perform empirical studies to validate hypotheses about runtime stemming from mathematical analysis.
Run algorithms on input of various sizes and compare performance. [Assessment]
7. Give examples that illustrate time-space trade-offs of algorithms. [Familiarity]

### Algorithmic Strategies [5 hours]

1. For each of the strategies (brute-force, greedy, divide-and-conquer, recursive backtracking, and dynamic
programming), identify a practical example to which it would apply. [Familiarity]
2. Use a greedy approach to solve an appropriate problem and determine if the greedy rule chosen leads to an
optimal solution. [Assessment]
3. Use a divide-and-conquer algorithm to solve an appropriate problem. [Usage]
4. Use recursive backtracking to solve a problem such as navigating a maze. [Usage]
5. Use dynamic programming to solve an appropriate problem. [Usage]
6. Determine an appropriate algorithmic approach to a problem. [Assessment]

### Fundamental Data Structures and Algorithms [9 hours]

1. Implement basic numerical algorithms. [Usage]
2. Implement simple search algorithms and explain the differences in their time complexities. [Assessment]
3. Be able to implement common quadratic and O(N log N) sorting algorithms. [Usage]
4. Describe the implementation of hash tables, including collision avoidance and resolution. [Familiarity]
5. Discuss the runtime and memory efficiency of principal algorithms for sorting, searching, and hashing.
[Familiarity]
6. Discuss factors other than computational efficiency that influence the choice of algorithms, such as
programming time, maintainability, and the use of application-specific patterns in the input data.
[Familiarity]
7. Explain how tree balance affects the efficiency of various binary search tree operations. [Familiarity]
8. Solve problems using fundamental graph algorithms, including depth-first and breadth-first search. [Usage]
9. Demonstrate the ability to evaluate algorithms, to select from a range of possible options, to provide
justification for that selection, and to implement the algorithm in a particular context. [Assessment]

### Basic Automata Computability and Complexity [3 hours]

1. Discuss the concept of finite state machines. [Familiarity]
2. Design a deterministic finite state machine to accept a specified language. [Usage]
3. Generate a regular expression to represent a specified language. [Usage]
4. Explain why the halting problem has no algorithmic solution. [Familiarity]

## ARCHITECTURE AND ORGANIZATION [0 hours]

## COMPUTATIONAL SCIENCE 

_cd: I think Haiyan's electives mostly sit here so we'll have strong coverage in any case._
_cd: These are not listed as CS1 learning objectives but I suspect we would find them there, with 3 maybe in M251_

### Introduction to Modeling and Simulation [1 hours]

1. Explain the concept of modeling and the use of abstraction that allows the use of a machine to solve a
problem. [Familiarity]
2. Describe the relationship between modeling and simulation, i.e., thinking of simulation as dynamic
modeling. [Familiarity]
3. Create a simple, formal mathematical model of a real-world situation and use that model in a simulation.
[Usage]
4. Differentiate among the different types of simulations, including physical simulations, human-guided
simulations, and virtual reality. [Familiarity]
5. Describe several approaches to validating models. [Familiarity]
6. Create a simple display of the results of a simulation. [Usage]

## DISCRETE STRUCTURES

### Proof Techniques [10 hours]

1. Identify the proof technique used in a given proof. [Familiarity]
2. Outline the basic structure of each proof technique (direct proof, proof by contradiction, and induction)
described in this unit. [Usage]
3. Apply each of the proof techniques (direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. [Usage]
4. Determine which type of proof is best for a given problem. [Assessment]
5. Explain the parallels between ideas of mathematical and/or structural induction to recursion and recursively
defined structures. [Assessment]
6. Explain the relationship between weak and strong induction and give examples of the appropriate use of
each. [Assessment]

### Basics of Counting [5 hours]

1. Apply counting arguments, including sum and product rules, inclusion-exclusion principle and
arithmetic/geometric progressions. [Usage]
2. Apply the pigeonhole principle in the context of a formal proof. [Usage]
3. Compute permutations and combinations of a set, and interpret the meaning in the context of the particular
application. [Usage]
4. Map real-world applications to appropriate counting formalisms, such as determining the number of ways
to arrange people around a table, subject to constraints on the seating arrangement, or the number of ways
to determine certain hands in cards (e.g., a full house). [Usage]
5. Solve a variety of basic recurrence relations. [Usage]
6. Analyze a problem to determine underlying recurrence relations. [Usage]
7. Perform computations involving modular arithmetic. [Usage]

### Graphs and Trees [3 hours]

1. Illustrate by example the basic terminology of graph theory, as well as some of the properties and special
cases of each type of graph/tree. [Familiarity]
2. Demonstrate different traversal methods for trees and graphs, including pre-, post-, and in-order traversal of
trees. [Usage]
3. Model a variety of real-world problems in computer science using appropriate forms of graphs and trees,
such as representing a network topology or the organization of a hierarchical file system. [Usage]
4. Show how concepts from graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. [Usage]

### Discrete Probability [6 hours]

5. Apply the tools of probability to solve problems such as the average case analysis of algorithms or
analyzing hashing. [Usage]
