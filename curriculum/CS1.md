# CS1

## COMPUTATIONAL SCIENCE 

### Introduction to Modeling and Simulation [1 hours]

_cd: added this one_

1. Explain the concept of modeling and the use of abstraction that allows the use of a machine to solve a
problem. [Familiarity]
2. Describe the relationship between modeling and simulation, i.e., thinking of simulation as dynamic
modeling. [Familiarity]
3. Create a simple, formal mathematical model of a real-world situation and use that model in a simulation.
[Usage]
4. Differentiate among the different types of simulations, including physical simulations, human-guided
simulations, and virtual reality. [Familiarity]
5. Describe several approaches to validating models. [Familiarity]
6. Create a simple display of the results of a simulation. [Usage]

## GRAPHICS AND VISUALIZATION

### Fundamental Concepts

_cd: specific to cd@[elon,unc].CS1_

2. Explain in general terms how analog signals can be reasonably represented by discrete samples, for
example, how images can be represented by pixels. [Familiarity]
3. Explain how the limits of human perception affect choices about the digital representation of analog
signals. [Familiarity]
5. Describe the differences between lossy and lossless image compression techniques, for example as
reflected in common graphics image file formats such as JPG, PNG, MP3, MP4, and GIF. [Familiarity]

## PROGRAMMING LANGUAGES

### Object-Oriented Programming [4 hours]

1. Design and implement a class. [Usage]
2. Use subclassing to design simple class hierarchies that allow code to be reused for distinct subclasses.
[Usage]
3. Correctly reason about control flow in a program using dynamic dispatch. [Usage]

### Functional Programming [3 hours]

1. Write basic algorithms that avoid assigning to mutable state or considering reference equality. [Usage]
2. Write useful functions that take and return other functions. [Usage]
3. Compare and contrast (1) the procedural/functional approach (defining a function for each operation with
the function body providing a case for each data variant) and (2) the object-oriented approach (defining a
class for each data variant with the class definition providing a method for each operation). Understand
both as defining a matrix of operations and variants. [Assessment]

### Basic Type Systems [1 hour]

1. For both a primitive and a compound type, informally describe the values that have that type. [Familiarity]
2. For a language with a static type system, describe the operations that are forbidden statically, such as
passing the wrong type of value to a function or method. [Familiarity]
3. Describe examples of program errors detected by a type system. [Familiarity]

## SOFTWARE DEVELOPMENT FUNDAMENTALS

### Algorithms and Design [11 hours]

1. Discuss the importance of algorithms in the problem-solving process. [Familiarity]
2. Discuss how a problem may be solved by multiple algorithms, each with different properties. [Familiarity]
3. Create algorithms for solving simple problems. [Usage]
4. Use a programming language to implement, test, and debug algorithms for solving simple problems.
[Usage]
5. Implement, test, and debug simple recursive functions and procedures. [Usage]
6. Determine whether a recursive or iterative solution is most appropriate for a problem. [Assessment]
7. Implement a divide-and-conquer algorithm for solving a problem. [Usage]
8. Apply the techniques of decomposition to break a program into smaller pieces. [Usage]
9. Identify the data components and behaviors of multiple abstract data types. [Usage]
10. Implement a coherent abstract data type, with loose coupling between components and behaviors. [Usage]
11. Identify the relative strengths and weaknesses among multiple designs or implementations for a problem.
[Assessment]

### Fundamental Programming Concepts [10 hours]

1. Analyze and explain the behavior of simple programs involving the fundamental programming
constructs variables, expressions, assignments, I/O, control constructs, functions, parameter passing,
and recursion. [Assessment]
2. Identify and describe uses of primitive data types. [Familiarity]
3. Write programs that use primitive data types. [Usage]
4. Modify and expand short programs that use standard conditional and iterative control structures and
functions. [Usage]
5. Design, implement, test, and debug a program that uses each of the following fundamental
programming constructs: basic computation, simple I/O, standard conditional and iterative structures,
the definition of functions, and parameter passing. [Usage]
6. Write a program that uses file I/O to provide persistence across multiple executions. [Usage]
7. Choose appropriate conditional and iteration constructs for a given programming task. [Assessment]
8. Describe the concept of recursion and give examples of its use. [Familiarity]
9. Identify the base case and the general case of a recursively-defined problem. [Assessment]

### Fundamental Data Structures [12 hours]

1. Discuss the appropriate use of built-in data structures. [Familiarity]
2. Describe common applications for each of the following data structures: stack, queue, priority queue, set,
and map. [Familiarity]
3. Write programs that use each of the following data structures: arrays, records/structs, strings, linked lists,
stacks, queues, sets, and maps. [Usage]

### Development Methods [10 hours]

3. Identify common coding errors that lead to insecure programs (e.g., buffer overflows, memory leaks,
malicious code) and apply strategies for avoiding such errors. [Usage]
7. Refactor a program by identifying opportunities to apply procedural abstraction. [Usage]
8. Apply a variety of strategies to the testing and debugging of simple programs. [Usage]
11. Analyze the extent to which another programmerâ€™s code meets documentation and programming style
standards. [Assessment]
12. Apply consistent documentation and program style standards that contribute to the readability and
maintainability of software. [Usage]

## SOFTWARE ENGINEERING

### Software Design [3 hours]

1. Articulate design principles including separation of concerns, information hiding, coupling and cohesion,
and encapsulation. [Familiarity]
2. Use a design paradigm to design a simple software system, and explain how system design principles have
been applied in this design. [Usage]
3. Construct models of the design of a simple software system that are appropriate for the paradigm used to
design it. [Usage]
4. Within the context of a single design paradigm, describe one or more design patterns that could be
applicable to the design of a simple software system. [Familiarity]
