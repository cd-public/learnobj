# Software

### cd: On Names

I believe this should be Software Engineering as many core learning objectives are specific to this field per the ACM whereas software development is distributed throughout the major, especially into Sys.

### cd: High Level

* Use Github.
* Write a mobile app that:
  * Interfaces with the OS
  * Uses an api.
  * Has a UI.
  * Is written in Java.
  * Is developed with a partner or two.
  * Is documented.

Stretch goal:

* The app:
  * Collects and renders data.

### cd: vs Roberts

I developed these goals independently then compared against Roberts' defined goals.

* (+) GRAPHICS AND VISUALIZATION
  * Necessary for a UI
* (+) INFORMATION MANAGEMENT
  * Necessary for partner/group work.
* (+) OPERATING SYSTEMS
  * Necessary to interface with OS.
* (+) PROGRAMMING LANGUAGES
  * Necessary for using Java.
* (-) SOFTWARE ENGINEERING: Tools and Environments
  * Not considered as not Tier 1
  * Intend to move Github to DS or CS1
* (+) SOFTWARE ENGINEERING: Software Design
  * Necessary to review.
* (+) SYSTEM FUNDAMENTALS:
  * Necessary to interface with OS.
  * Teaching techniques intended for app/UI design.


## GRAPHICS AND VISUALIZATION

### Fundamental Concepts

1. Identify common uses of digital presentation to humans (e.g., computer graphics, sound). [Familiarity]
4. Construct a simple user interface using a standard API. [Usage]

## HUMAN COMPUTER INTERACTION

### Foundations

1. Discuss why human-centered software development is important. [Familiarity]
2. Summarize the basic precepts of psychological and social interaction. [Familiarity]
3. Develop and use a conceptual vocabulary for analyzing human interaction with software: affordance,
conceptual model, feedback, and so forth. [Usage]
4. Define a user-centered design process that explicitly takes account of the fact that the user is not like the
developer or their acquaintances. [Usage]
5. Create and conduct a simple usability test for an existing software application. [Assessment]

## INFORMATION ASSURANCE AND SECURITY

### Principles of Secure Design [1 hour]

1. Describe the principle of least privilege and isolation as applied to system design. [Familiarity]
2. Summarize the principle of fail-safe and deny-by-default. [Familiarity]
3. Discuss the implications of relying on open design or the secrecy of design for security. [Familiarity]
4. Explain the goals of end-to-end data security. [Familiarity]
5. Discuss the benefits of having multiple layers of defenses. [Familiarity]
6. For each stage in the lifecycle of a product, describe what security considerations should be evaluated.
[Familiarity]
7. Describe the cost and tradeoffs associated with designing security into a product. [Familiarity]

### Defensive Programming [1 hour]

1. Explain why input validation and data sanitization is necessary in the face of adversarial control of the
input channel. [Familiarity]
2. Explain why you might choose to develop a program in a type-safe language like Java, in contrast to an
unsafe programming language like C/C++. [Familiarity]
3. Classify common input validation errors, and write correct input validation code. [Usage]
4. Demonstrate using a high-level programming language how to prevent a race condition from occurring and
how to handle an exception. [Usage]
5. Demonstrate the identification and graceful handling of error conditions. [Usage]

## INFORMATION MANAGEMENT

### Information Management Concepts [1 hour]

1. Describe how humans gain access to information and data to support their needs. [Familiarity]
6. Identify issues of data persistence for an organization. [Familiarity]

## OPERATING SYSTEMS [4 hours]

### Operating System Principles

1. Explain the concept of a logical layer. [Familiarity]
2. Explain the benefits of building abstract layers in hierarchical fashion. [Familiarity]
3. Describe the value of APIs and middleware. [Assessment]
4. Describe how computing resources are used by application software and managed by system software.
[Familiarity]
5. Contrast kernel and user mode in an operating system. [Usage]
6. Discuss the advantages and disadvantages of using interrupt processing. [Familiarity]
7. Explain the use of a device list and driver I/O queue. [Familiarity]

## PROGRAMMING LANGUAGES

### Basic Type Systems [1 hour]

1. For both a primitive and a compound type, informally describe the values that have that type. [Familiarity]
2. For a language with a static type system, describe the operations that are forbidden statically, such as
passing the wrong type of value to a function or method. [Familiarity]
3. Describe examples of program errors detected by a type system. [Familiarity]
4. For multiple programming languages, identify program properties checked statically and program
properties checked dynamically. [Usage]
5. Give an example program that does not type-check in a particular language and yet would have no error if
run. [Familiarity]
6. Use types and type-error messages to write and debug programs. [Usage]

## SOFTWARE DEVELOPMENT FUNDAMENTALS

### Development Methods [10 hours]

1. Trace the execution of a variety of code segments and write summaries of their computations. [Assessment]
2. Explain why the creation of correct program components is important in the production of high-quality
software. [Familiarity]
4. Conduct a personal code review (focused on common coding errors) on a program component using a
provided checklist. [Usage]
5. Contribute to a small-team code review focused on component correctness. [Usage]
6. Describe how a contract can be used to specify the behavior of a program component. [Familiarity]
7. Refactor a program by identifying opportunities to apply procedural abstraction. [Usage]
8. Apply a variety of strategies to the testing and debugging of simple programs. [Usage]
9. Construct, execute and debug programs using a modern IDE and associated tools such as unit testing tools
and visual debuggers. [Usage]
10. Construct and debug programs using the standard libraries available with a chosen programming language.
[Usage]
11. Analyze the extent to which another programmerâ€™s code meets documentation and programming style
standards. [Assessment]
12. Apply consistent documentation and program style standards that contribute to the readability and
maintainability of software. [Usage]

## SOFTWARE ENGINEERING

_cd: Still believe this should be the name of the course._

### Software Processes [2 hours]

1. Describe how software can interact with and participate in various systems including information
management, embedded, process control, and communications systems. [Familiarity]
2. Describe the relative advantages and disadvantages among several major process models (e.g., waterfall,
iterative, and agile). [Familiarity]
3. Describe the different practices that are key components of various process models. [Familiarity]
4. Differentiate among the phases of software development. [Familiarity]
5. Describe how programming in the large differs from individual efforts with respect to understanding a large
code base, code reading, understanding builds, and understanding context of changes. [Familiarity]

### Requirements Engineering [1 hour]

1. List the key components of a use case or similar description of some behavior that is required for a system.
[Familiarity]
2. Describe how the requirements engineering process supports the elicitation and validation of behavioral
requirements. [Familiarity]
3. Interpret a given requirements model for a simple software system. [Familiarity]

### Software Design [3 hours]

1. Articulate design principles including separation of concerns, information hiding, coupling and cohesion,
and encapsulation. [Familiarity]
2. Use a design paradigm to design a simple software system, and explain how system design principles have
been applied in this design. [Usage]
3. Construct models of the design of a simple software system that are appropriate for the paradigm used to
design it. [Usage]
4. Within the context of a single design paradigm, describe one or more design patterns that could be
applicable to the design of a simple software system. [Familiarity]

## SYSTEM FUNDAMENTALS

### Cross-Layer Communications [3 hours]

1. Describe how computing systems are constructed of layers upon layers, based on separation of concerns,
with well-defined interfaces, hiding details of low layers from the higher layers. [Familiarity]
2. Describe how hardware, VM, OS, and applications are additional layers of interpretation/processing.
[Familiarity]
3. Describe the mechanisms of how errors are detected, signaled back, and handled through the layers.
[Familiarity]
4. Construct a simple program using methods of layering, error detection and recovery, and reflection of error
status across layers. [Usage]
5. Find bugs in a layered program by using tools for program tracing, single stepping, and debugging. [Usage]

### State and State Machines [6 hours]

3. Describe a computer as a state machine that interprets machine instructions. [Familiarity]
4. Explain how a program or network protocol can also be expressed as a state machine, and that alternative
representations for the same computation can exist. [Familiarity]
5. Develop state machine descriptions for simple problem statement solutions (e.g., traffic light sequencing,
pattern recognizers). [Usage]
6. Derive time-series behavior of a state machine from its state machine representation. [Assessment]
