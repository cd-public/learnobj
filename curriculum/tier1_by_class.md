ALGORITHMS

Basic Analysis [2 hours]

cd: 1-3, 6-7 in DS; 1-7 in Alg

1. Explain what is meant by “best”, “expected”, and “worst” case behavior of an algorithm. [Familiarity]
2. In the context of specific algorithms, identify the characteristics of data and/or other conditions or
assumptions that lead to different behaviors. [Assessment]
3. Determine informally the time and space complexity of simple algorithms. [Usage]
4. State the formal definition of big O. [Familiarity]
5. List and contrast standard complexity classes. [Familiarity]
6. Perform empirical studies to validate hypotheses about runtime stemming from mathematical analysis.
Run algorithms on input of various sizes and compare performance. [Assessment]
7. Give examples that illustrate time-space trade-offs of algorithms. [Familiarity]

Algorithmic Strategies [5 hours]

cd: 1-6 in Alg

1. For each of the strategies (brute-force, greedy, divide-and-conquer, recursive backtracking, and dynamic
programming), identify a practical example to which it would apply. [Familiarity]
2. Use a greedy approach to solve an appropriate problem and determine if the greedy rule chosen leads to an
optimal solution. [Assessment]
3. Use a divide-and-conquer algorithm to solve an appropriate problem. [Usage]
4. Use recursive backtracking to solve a problem such as navigating a maze. [Usage]
5. Use dynamic programming to solve an appropriate problem. [Usage]
6. Determine an appropriate algorithmic approach to a problem. [Assessment]

Fundamental Data Structures and Algorithms [9 hours]

cd: 1-7, 9 in DS; 1-9 in Alg

1. Implement basic numerical algorithms. [Usage]
2. Implement simple search algorithms and explain the differences in their time complexities. [Assessment]
3. Be able to implement common quadratic and O(N log N) sorting algorithms. [Usage]
4. Describe the implementation of hash tables, including collision avoidance and resolution. [Familiarity]
5. Discuss the runtime and memory efficiency of principal algorithms for sorting, searching, and hashing.
[Familiarity]
6. Discuss factors other than computational efficiency that influence the choice of algorithms, such as
programming time, maintainability, and the use of application-specific patterns in the input data.
[Familiarity]
7. Explain how tree balance affects the efficiency of various binary search tree operations. [Familiarity]
8. Solve problems using fundamental graph algorithms, including depth-first and breadth-first search. [Usage]
9. Demonstrate the ability to evaluate algorithms, to select from a range of possible options, to provide
justification for that selection, and to implement the algorithm in a particular context. [Assessment]

Basic Automata Computability and Complexity [3 hours]

cd: 1-4 in Alg

1. Discuss the concept of finite state machines. [Familiarity]
2. Design a deterministic finite state machine to accept a specified language. [Usage]
3. Generate a regular expression to represent a specified language. [Usage]
4. Explain why the halting problem has no algorithmic solution. [Familiarity]

ARCHITECTURE AND ORGANIZATION [0 hours]

cd: my electives here, this becomes mandatory with an engineering school (+ will require an EECS hire I suspect)

COMPUTATIONAL SCIENCE 

cd: I think Haiyan's electives mostly sit here so we'll have strong coverage in any case.

Introduction to Modeling and Simulation [1 hours]

cd: 1-6 in CS1; 1-6 in Alg

1. Explain the concept of modeling and the use of abstraction that allows the use of a machine to solve a
problem. [Familiarity]
2. Describe the relationship between modeling and simulation, i.e., thinking of simulation as dynamic
modeling. [Familiarity]
3. Create a simple, formal mathematical model of a real-world situation and use that model in a simulation.
[Usage]
4. Differentiate among the different types of simulations, including physical simulations, human-guided
simulations, and virtual reality. [Familiarity]
5. Describe several approaches to validating models. [Familiarity]
6. Create a simple display of the results of a simulation. [Usage]

DISCRETE STRUCTURES

cd: this is basically all in M251 and we have strong coverage in DS/Alg

Sets, Relations, and Functions [4 hours]

cd: Functions and relations in DS; 1-3 in M251

1. Explain with examples the basic terminology of functions, relations, and sets. [Familiarity]
2. Perform the operations associated with sets, functions, and relations. [Usage]
3. Relate practical examples to the appropriate set, function, or relation model, and interpret the associated
operations and terminology in context. [Assessment]

Basic Logic [9 hours]

cd: 1-2, 4 in DS; 1-6 in M251

1. Convert logical statements from informal language to propositional and predicate logic expressions.
[Usage]
2. Apply formal methods of symbolic propositional and predicate logic, such as calculating validity of
formulae and computing normal forms. [Usage]
3. Use the rules of inference to construct proofs in propositional and predicate logic. [Usage]
4. Describe how symbolic logic can be used to model real-life situations or applications, including those
arising in computing contexts such as software analysis (e.g., program correctness), database queries, and
algorithms. [Usage]
5. Apply formal logic proofs and/or informal, but rigorous, logical reasoning to real problems, such as
predicting the behavior of software or solving problems such as puzzles. [Usage]
6. Describe the strengths and limitations of propositional and predicate logic. [Familiarity]

Proof Techniques [10 hours]

cd: 1-6 in M251; 5 in DS; 1-6 in Alg

1. Identify the proof technique used in a given proof. [Familiarity]
2. Outline the basic structure of each proof technique (direct proof, proof by contradiction, and induction)
described in this unit. [Usage]
3. Apply each of the proof techniques (direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. [Usage]
4. Determine which type of proof is best for a given problem. [Assessment]
5. Explain the parallels between ideas of mathematical and/or structural induction to recursion and recursively
defined structures. [Assessment]
6. Explain the relationship between weak and strong induction and give examples of the appropriate use of
each. [Assessment]

Basics of Counting [5 hours]

cd: 1-7 in M251; 5-7 in DS; 1-7 in Alg

1. Apply counting arguments, including sum and product rules, inclusion-exclusion principle and
arithmetic/geometric progressions. [Usage]
2. Apply the pigeonhole principle in the context of a formal proof. [Usage]
3. Compute permutations and combinations of a set, and interpret the meaning in the context of the particular
application. [Usage]
4. Map real-world applications to appropriate counting formalisms, such as determining the number of ways
to arrange people around a table, subject to constraints on the seating arrangement, or the number of ways
to determine certain hands in cards (e.g., a full house). [Usage]
5. Solve a variety of basic recurrence relations. [Usage]
6. Analyze a problem to determine underlying recurrence relations. [Usage]
7. Perform computations involving modular arithmetic. [Usage]

Graphs and Trees [3 hours]

cd: 1-4 in Alg, 1-4 for trees in DS; 1 in M251

1. Illustrate by example the basic terminology of graph theory, as well as some of the properties and special
cases of each type of graph/tree. [Familiarity]
2. Demonstrate different traversal methods for trees and graphs, including pre-, post-, and in-order traversal of
trees. [Usage]
3. Model a variety of real-world problems in computer science using appropriate forms of graphs and trees,
such as representing a network topology or the organization of a hierarchical file system. [Usage]
4. Show how concepts from graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. [Usage]

Discrete Probability [6 hours]

cd: 1-5 in M251; 5 in DS; 5 in Alg

1. Calculate probabilities of events and expectations of random variables for elementary problems such as
games of chance. [Usage]
2. Differentiate between dependent and independent events. [Usage]
3. Identify a case of the binomial distribution and compute a probability using that distribution. [Usage]
4. Apply Bayes theorem to determine conditional probabilities in a problem. [Usage]
5. Apply the tools of probability to solve problems such as the average case analysis of algorithms or
analyzing hashing. [Usage]

GRAPHICS AND VISUALIZATION

cd: Ballpark 90% of our students want a game design, serious games, or gamification course elective here and in HCI

Fundamental Concepts

cd: 2-3, 5 in cd@[elon,unc].CS1; 1, 4 in SW

1. Identify common uses of digital presentation to humans (e.g., computer graphics, sound). [Familiarity]
2. Explain in general terms how analog signals can be reasonably represented by discrete samples, for
example, how images can be represented by pixels. [Familiarity]
3. Explain how the limits of human perception affect choices about the digital representation of analog
signals. [Familiarity]
4. Construct a simple user interface using a standard API. [Usage]
5. Describe the differences between lossy and lossless image compression techniques, for example as
reflected in common graphics image file formats such as JPG, PNG, MP3, MP4, and GIF. [Familiarity]

HUMAN COMPUTER INTERACTION

cd: Ballpark 90% of our students want a game design, serious games, or gamification course elective here and in GV.
cd: We could do games for SW but I am anti-games requirement for accessibility reasons.
cd: There's a security mention here.

Foundations

cd: 1-5 in SW

1. Discuss why human-centered software development is important. [Familiarity]
2. Summarize the basic precepts of psychological and social interaction. [Familiarity]
3. Develop and use a conceptual vocabulary for analyzing human interaction with software: affordance,
conceptual model, feedback, and so forth. [Usage]
4. Define a user-centered design process that explicitly takes account of the fact that the user is not like the
developer or their acquaintances. [Usage]
5. Create and conduct a simple usability test for an existing software application. [Assessment]

INFORMATION ASSURANCE AND SECURITY

cd: These need to be embedded in our engineering sequence, but I don't want to put them all in SW rather than networks.

Foundational Concepts in Security [1 hour]

cd: 1-5 in Sys

1. Analyze the tradeoffs of balancing key security properties (Confidentiality, Integrity, and Availability).
[Usage]
2. Describe the concepts of risk, threats, vulnerabilities and attack vectors (including the fact that there is no
such thing as perfect security). [Familiarity]
3. Explain the concepts of authentication, authorization, access control. [Familiarity]
4. Explain the concept of trust and trustworthiness. [Familiarity]
5. Describe important ethical issues to consider in computer security, including ethical issues associated with
fixing or not fixing vulnerabilities and disclosing or not disclosing vulnerabilities. [Familiarity]

Principles of Secure Design [1 hour]

cd: 1-7 in SW, 3-5, 7 in Sys

1. Describe the principle of least privilege and isolation as applied to system design. [Familiarity]
2. Summarize the principle of fail-safe and deny-by-default. [Familiarity]
3. Discuss the implications of relying on open design or the secrecy of design for security. [Familiarity]
4. Explain the goals of end-to-end data security. [Familiarity]
5. Discuss the benefits of having multiple layers of defenses. [Familiarity]
6. For each stage in the lifecycle of a product, describe what security considerations should be evaluated.
[Familiarity]
7. Describe the cost and tradeoffs associated with designing security into a product. [Familiarity]

Defensive Programming [1 hour]

cd: 1-3, 5 in DS; 1-5 in SW, 1-5 in Sys

1. Explain why input validation and data sanitization is necessary in the face of adversarial control of the
input channel. [Familiarity]
2. Explain why you might choose to develop a program in a type-safe language like Java, in contrast to an
unsafe programming language like C/C++. [Familiarity]
3. Classify common input validation errors, and write correct input validation code. [Usage]
4. Demonstrate using a high-level programming language how to prevent a race condition from occurring and
how to handle an exception. [Usage]
5. Demonstrate the identification and graceful handling of error conditions. [Usage]

INFORMATION MANAGEMENT

cd: This is down as in ethics but will have to be covered in SW/Sys. We need a databases elective.

Information Management Concepts [1 hour]

cd: 1-6 in Ethics, 1, 6 in SW, 1-6 in Sys

1. Describe how humans gain access to information and data to support their needs. [Familiarity]
2. Describe the advantages and disadvantages of central organizational control over data. [Assessment]
3. Identify the careers/roles associated with information management (e.g., database administrator, data
modeler, application developer, end-user). [Familiarity]
4. Compare and contrast information with data and knowledge. [Assessment]
5. Demonstrate uses of explicitly stored metadata/schema associated with data. [Usage]
6. Identify issues of data persistence for an organization. [Familiarity]

NETWORKING AND COMMUNICATION

cd: trivially in Sys

Introduction [1.5 hours]

cd: 1-4 in Sys

1. Articulate the organization of the Internet. [Familiarity]
2. List and define the appropriate network terminology. [Familiarity]
3. Describe the layered structure of a typical networked architecture. [Familiarity]
4. Identify the different types of complexity in a network (edges, core, etc.). [Familiarity]

Networked Applications [1.5 hours]

cd: 1-3 in Sys

1. List the differences and the relations between names and addresses in a network. [Familiarity]
2. Define the principles behind naming schemes and resource location. [Familiarity]
3. Implement a simple client-server socket-based application. [Usage]

OPERATING SYSTEMS [4 hours]

cd: trivially in Sys

Overview of Operating Systems

cd: 1-5 in Sys

1. Explain the objectives and functions of modern operating systems. [Familiarity]
2. Analyze the tradeoffs inherent in operating system design. [Usage]
3. Describe the functions of a contemporary operating system with respect to convenience, efficiency, and the
ability to evolve. [Familiarity]
4. Discuss networked, client-server, distributed operating systems and how they differ from single user
operating systems. [Familiarity]
5. Identify potential threats to operating systems and the security features design to guard against them.
[Familiarity]

Operating System Principles

cd: 1-7 in SW

1. Explain the concept of a logical layer. [Familiarity]
2. Explain the benefits of building abstract layers in hierarchical fashion. [Familiarity]
3. Describe the value of APIs and middleware. [Assessment]
4. Describe how computing resources are used by application software and managed by system software.
[Familiarity]
5. Contrast kernel and user mode in an operating system. [Usage]
6. Discuss the advantages and disadvantages of using interrupt processing. [Familiarity]
7. Explain the use of a device list and driver I/O queue. [Familiarity]

PARALLEL AND DISTRIBUTED COMPUTING

cd: This is just networks but also contains the only required architecture topics which is VERY odd.

Parallelism Fundamentals [2 hours]

cd: 1-3 in Sys

1. Distinguish using computational resources for a faster answer from managing efficient access to a shared
resource. [Familiarity]
2. Distinguish multiple sufficient programming constructs for synchronization that may be interimplementable but have complementary advantages. [Familiarity]
3. Distinguish data races from higher level races. [Familiarity]

Parallel Decomposition [1 hour]

cd: 1-2 in Sys

1. Explain why synchronization is necessary in a specific parallel program. [Usage]
2. Identify opportunities to partition a serial program into independent parallel modules. [Familiarity]

Communication and Coordination [1 hour]

cd: 1-2 in Sys

1. Use mutual exclusion to avoid a given race condition. [Usage]
2. Give an example of an ordering of accesses among concurrent activities (e.g., program with a data race)
that is not sequentially consistent. [Familiarity]

Parallel Architecture [1 hour]

cd: 1 in Sys

1. Explain the differences between shared and distributed memory. [Familiarity]

PROGRAMMING LANGUAGES

cd: This looks more like a Java CS1 syllabus than the topic of languages. 
	re this, See Joel: https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/
cd: Having 3 host languages in the 4 coding courses, as currently planned, will go a long way here.

Object-Oriented Programming [4 hours]

cd: 1-3 in CS1; 1-4 in DS; 3 in Sys

1. Design and implement a class. [Usage]
2. Use subclassing to design simple class hierarchies that allow code to be reused for distinct subclasses.
[Usage]
3. Correctly reason about control flow in a program using dynamic dispatch. [Usage]
4. Compare and contrast (1) the procedural/functional approach (defining a function for each operation with
the function body providing a case for each data variant) and (2) the object-oriented approach (defining a
class for each data variant with the class definition providing a method for each operation). Understand
both as defining a matrix of operations and variants. [Assessment]

Functional Programming [3 hours]

cd: 1-3 in CS1; 1-3 in DS

1. Write basic algorithms that avoid assigning to mutable state or considering reference equality. [Usage]
2. Write useful functions that take and return other functions. [Usage]
3. OOP.4

Basic Type Systems [1 hour]

cd: 1-3 in CS1; 1, 3, 5-6 in DS; 1-6 in Sys; 1-6 in SW

1. For both a primitive and a compound type, informally describe the values that have that type. [Familiarity]
2. For a language with a static type system, describe the operations that are forbidden statically, such as
passing the wrong type of value to a function or method. [Familiarity]
3. Describe examples of program errors detected by a type system. [Familiarity]
4. For multiple programming languages, identify program properties checked statically and program
properties checked dynamically. [Usage]
5. Give an example program that does not type-check in a particular language and yet would have no error if
run. [Familiarity]
6. Use types and type-error messages to write and debug programs. [Usage]

SOFTWARE DEVELOPMENT FUNDAMENTALS

cd: I don't understand this category. It feels like things that should be distributed above.
cd: Development methods alone touches on, in my view, at least four distinct concepts with total separation.
cd: With ~none of these landing in SW I'm renewing my call for SW to be Engineering not Development

Algorithms and Design [11 hours]

cd: 1-11 in CS1; 1-11 in DS; 1-4, 7, 11 in Alg

1. Discuss the importance of algorithms in the problem-solving process. [Familiarity]
2. Discuss how a problem may be solved by multiple algorithms, each with different properties. [Familiarity]
3. Create algorithms for solving simple problems. [Usage]
4. Use a programming language to implement, test, and debug algorithms for solving simple problems.
[Usage]
5. Implement, test, and debug simple recursive functions and procedures. [Usage]
6. Determine whether a recursive or iterative solution is most appropriate for a problem. [Assessment]
7. Implement a divide-and-conquer algorithm for solving a problem. [Usage]
8. Apply the techniques of decomposition to break a program into smaller pieces. [Usage]
9. Identify the data components and behaviors of multiple abstract data types. [Usage]
10. Implement a coherent abstract data type, with loose coupling between components and behaviors. [Usage]
11. Identify the relative strengths and weaknesses among multiple designs or implementations for a problem.
[Assessment]

Fundamental Programming Concepts [10 hours]

cd: 1-9 in CS1; 1-5, 7-9 in DS; 6 in Sys; 2, 8-9 in Alg

1. Analyze and explain the behavior of simple programs involving the fundamental programming
constructs variables, expressions, assignments, I/O, control constructs, functions, parameter passing,
and recursion. [Assessment]
2. Identify and describe uses of primitive data types. [Familiarity]
3. Write programs that use primitive data types. [Usage]
4. Modify and expand short programs that use standard conditional and iterative control structures and
functions. [Usage]
5. Design, implement, test, and debug a program that uses each of the following fundamental
programming constructs: basic computation, simple I/O, standard conditional and iterative structures,
the definition of functions, and parameter passing. [Usage]
6. Write a program that uses file I/O to provide persistence across multiple executions. [Usage]
7. Choose appropriate conditional and iteration constructs for a given programming task. [Assessment]
8. Describe the concept of recursion and give examples of its use. [Familiarity]
9. Identify the base case and the general case of a recursively-defined problem. [Assessment]

Fundamental Data Structures [12 hours]

cd: 1-3 in CS1; 1-7 in DS; 2, 4, 7 in Alg

1. Discuss the appropriate use of built-in data structures. [Familiarity]
2. Describe common applications for each of the following data structures: stack, queue, priority queue, set,
and map. [Familiarity]
3. Write programs that use each of the following data structures: arrays, records/structs, strings, linked lists,
stacks, queues, sets, and maps. [Usage]
4. Compare alternative implementations of data structures with respect to performance. [Assessment]
5. Describe how references allow for objects to be accessed in multiple ways. [Familiarity]
6. Compare and contrast the costs and benefits of dynamic and static data structure implementations.
[Assessment]
7. Choose the appropriate data structure for modeling a given problem. [Assessment]

Development Methods [10 hours]

cd: 3, 7-8, 11-12 in CS1; 1, 6-8 in DS; 1-2, 4-12 in SW; 1-3, 8-10 in Sys

1. Trace the execution of a variety of code segments and write summaries of their computations. [Assessment]
2. Explain why the creation of correct program components is important in the production of high-quality
software. [Familiarity]
3. Identify common coding errors that lead to insecure programs (e.g., buffer overflows, memory leaks,
malicious code) and apply strategies for avoiding such errors. [Usage]
4. Conduct a personal code review (focused on common coding errors) on a program component using a
provided checklist. [Usage]
5. Contribute to a small-team code review focused on component correctness. [Usage]
6. Describe how a contract can be used to specify the behavior of a program component. [Familiarity]
7. Refactor a program by identifying opportunities to apply procedural abstraction. [Usage]
8. Apply a variety of strategies to the testing and debugging of simple programs. [Usage]
9. Construct, execute and debug programs using a modern IDE and associated tools such as unit testing tools
and visual debuggers. [Usage]
10. Construct and debug programs using the standard libraries available with a chosen programming language.
[Usage]
11. Analyze the extent to which another programmer’s code meets documentation and programming style
standards. [Assessment]
12. Apply consistent documentation and program style standards that contribute to the readability and
maintainability of software. [Usage]

SOFTWARE ENGINEERING

cd: This is the topic set intended for coverage in SW

Software Processes [2 hours]

cd: 1, 5 in Sys; 1-5 in SW

1. Describe how software can interact with and participate in various systems including information
management, embedded, process control, and communications systems. [Familiarity]
2. Describe the relative advantages and disadvantages among several major process models (e.g., waterfall,
iterative, and agile). [Familiarity]
3. Describe the different practices that are key components of various process models. [Familiarity]
4. Differentiate among the phases of software development. [Familiarity]
5. Describe how programming in the large differs from individual efforts with respect to understanding a large
code base, code reading, understanding builds, and understanding context of changes. [Familiarity]

Requirements Engineering [1 hour]

cd: 1-3 in SW

1. List the key components of a use case or similar description of some behavior that is required for a system.
[Familiarity]
2. Describe how the requirements engineering process supports the elicitation and validation of behavioral
requirements. [Familiarity]
3. Interpret a given requirements model for a simple software system. [Familiarity]

Software Design [3 hours]

cd: 1-4 in CS1; 1-4 in DS; 1-4 in SW

1. Articulate design principles including separation of concerns, information hiding, coupling and cohesion,
and encapsulation. [Familiarity]
2. Use a design paradigm to design a simple software system, and explain how system design principles have
been applied in this design. [Usage]
3. Construct models of the design of a simple software system that are appropriate for the paradigm used to
design it. [Usage]
4. Within the context of a single design paradigm, describe one or more design patterns that could be
applicable to the design of a simple software system. [Familiarity]

SYSTEM FUNDAMENTALS

cd: These aren't cleanly separable into Sys and SW since Sys will describe and SW will use.

Computational Paradigms [3 hours]

cd: 1-8 in Sys

1. List commonly encountered patterns of how computations are organized. [Familiarity]
2. Describe the basic building blocks of computers and their role in the historical development of computer
architecture. [Familiarity]
3. Articulate the differences between single thread vs. multiple thread, single server vs. multiple server
models, motivated by real world examples (e.g., cooking recipes, lines for multiple teller machines and
couples shopping for food). [Familiarity]
4. Articulate the concept of strong vs. weak scaling, i.e., how performance is affected by scale of problem vs.
scale of resources to solve the problem. This can be motivated by the simple, real-world examples.
[Familiarity]
5. Design a simple logic circuit using the fundamental building blocks of logic design. [Usage]
6. Use tools for capture, synthesis, and simulation to evaluate a logic design. [Usage]
7. Write a simple sequential problem and a simple parallel version of the same program. [Usage]
8. Evaluate performance of simple sequential and parallel versions of a program with different problem sizes,
and be able to describe the speed-ups achieved. [Assessment]

Cross-Layer Communications [3 hours]

cd: 1-4 in DS; 1-5 in SW; 1-5 in Sys

1. Describe how computing systems are constructed of layers upon layers, based on separation of concerns,
with well-defined interfaces, hiding details of low layers from the higher layers. [Familiarity]
2. Describe how hardware, VM, OS, and applications are additional layers of interpretation/processing.
[Familiarity]
3. Describe the mechanisms of how errors are detected, signaled back, and handled through the layers.
[Familiarity]
4. Construct a simple program using methods of layering, error detection and recovery, and reflection of error
status across layers. [Usage]
5. Find bugs in a layered program by using tools for program tracing, single stepping, and debugging. [Usage]

State and State Machines [6 hours]

cd: 1-2 in DS, 1-6 in Sys, 3-6 in SW

1. Describe computations as a system characyterized by a known set of configurations with transitions from
one unique configuration (state) to another (state). [Familiarity]
2. Describe the distinction between systems whose output is only a function of their input (Combinational)
and those with memory/history (Sequential). [Familiarity]
3. Describe a computer as a state machine that interprets machine instructions. [Familiarity]
4. Explain how a program or network protocol can also be expressed as a state machine, and that alternative
representations for the same computation can exist. [Familiarity]
5. Develop state machine descriptions for simple problem statement solutions (e.g., traffic light sequencing,
pattern recognizers). [Usage]
6. Derive time-series behavior of a state machine from its state machine representation. [Assessment]

Parallelism [3 hours]

cd: 1-6 in Sys

1. For a given program, distinguish between its sequential and parallel execution, and the performance
implications thereof. [Familiarity]
2. Demonstrate on an execution time line that parallelism events and operations can take place simultaneously
(i.e., at the same time). Explain how work can be performed in less elapsed time if this can be exploited.
[Familiarity]
3. Explain other uses of parallelism, such as for reliability/redundancy of execution. [Familiarity]
4. Define the differences between the concepts of Instruction Parallelism, Data Parallelism, Thread
Parallelism/Multitasking, Task/Request Parallelism. [Familiarity]
5. Write more than one parallel program (e.g., one simple parallel program in more than one parallel
programming paradigm; a simple parallel program that manages shared resources through synchronization
primitives; a simple parallel program that performs simultaneous operation on partitioned data through task
parallel (e.g., parallel search terms; a simple parallel program that performs step-by-step pipeline
processing through message passing). [Usage]
6. Use performance tools to measure speed-up achieved by parallel programs in terms of both problem size
and number of resources. [Assessment]

Evaluation [3 hours]

cd: 1-4 in Sys

1. Explain how the components of system architecture contribute to improving its performance. [Familiarity]
2. Describe Amdahl’s law and discuss its limitations. [Familiarity]
3. Design and conduct a performance-oriented experiment. [Usage]
4. Use software tools to profile and measure program performance. [Assessment]

SOCIAL ISSUES AND PROFESSIONAL PRACTICE

cd: I remain convinced this should be not be taught in-house.
cd: This all would've been covered by 451: Computer Security.

* [11 hours]

cd: * in Ethics



